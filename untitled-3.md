# index

## 线性表

线性结构的特点：在数据元素的非空有限集中

1. 存在唯一的一个被称为“第一个“的数据元素
2. 存在唯一的一个被称作“最后一个”的数据元素
3. 除第一个之外，集合中的每个数据元素均只有一个前驱
4. 除最后一个之外，集合中每个数据元素均只有一个后继

### 线性表的类型定义

线性表\(Linear List\)：由n\($n{\geq0}$\)个同类型**数据元素**构成**有序序列**的线性结构

* 表中元素个数称为线性表的长度
* 线性表没有元素时，称为空表
* 在非空表中的每个数据元素都有一个确定的位置，如$a\_i$表示是第i个元素
* 表起始位置称表头，表结束位置称表尾

线性表是一个相当灵活的数据结构，它的长度可根据需要增长或缩短，即对线性表的数据元素不仅可以进行访问，还可以进行插入和删除等操作。

线性表基本操作：

1. `List MakeEmpty()`:初始化一个空线性表L;
2. `ElementType FindKth( int K, List L )`:根据位序K，返回相应元素 ; 
3. `int Find( ElementType X, List L )`:在线性表L中查找X的第一次出现位置; 
4. `void Insert( ElementType X, int i, List L)`:在位序i前插入一个新元素X; 
5. `void Delete( int i, List L )`:删除指定位序i的元素;
6. `int Length( List L )`:返回线性表L的长度n。

### 线性表的顺序存储实现

线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素。**在语言中，一般用数组表示**。线性表的顺序存储结构的特点是逻辑关系上相邻的两个元素在物理位置上也相邻，因此可以随机存取表中任何一个元素。然而，在做插入或删除操作时，需要移动大量元素。

利用数组的**连续存储空间顺序**存放线性表的各元素

主要操作的实现

1. 初始化

   建立空的顺序表

2. 查找

   在顺序存储里面，查找是遍历查找。最快1次找到，最慢n次找到。所以查找成功的平均次数为\(n+1\)/2，时间复杂度为O\(n\)

3. 插入

   在第$i\(1{\leq}i{\leq}n+1\)$个位置上插入一个值为X的新元素

   在插入中，平均移动次数为n/2，时间复杂度为O\(n\)

4. 删除

   删除表的第$i\(1{\leq}i{\leq}n\)$个位置上的元素

   在删除中，平均移动次数为\(n-1\)/2，时间复杂度为O\(n\)

### 线性表的链式存储实现

链式存储结构，不要求逻辑上相邻的元素在物理位置上也相邻，因此它没有顺序存储结构所具有的弱点，但同时也失去了顺序表可随机存取的优点。

因此，为了表示每个数据元素$a_i$与其直接后继数据元素$a_{i+1}$之间的逻辑关系，对数据元素$a\_i$来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息\(即直接后继的存储位置\)。这两部分信息组成数据元素$a\_i$的存储映像，成为节点\(node\)。 它包括两个域：其中存储数据元素信息的域成为数据域，存储直接后继存储位置的域称为指针域。指针域中存储的信息乘坐指针或链。 通过“链”建立起数据元素之间的逻辑关系。存储data和下一个数据的地址。

根据链表结点所含指针个数、指针指向和指针连接方式，可将链表分为单链表、循环链表、 双向链表、二叉链表、十字链表、邻接表、邻接多重表等。其中单链表、循环链表和双向链表用于实现线性表的链式存储结构，其他形式多用于实现树和图等非线性结构。

#### 单链表

主要操作的实现

1. 求表长

   链式存储不知道数据到底有多长，所以需要遍历统计表的长度，时间复杂度为O\(n\)

2. 查找

   查找分为按序号查找和按值查找。两者都需要遍历查找，所以时间复杂度为O\(n\)

3. 插入

   在第$i-1\(1{\leq}i{\leq}n+1\)$个节点后插入一个值为X的新节点

   1. 先构造一个新节点s
   2. 再找到链表的第i-1个节点p
   3. s.next=p.next; p.next=s; 这样就重连链接了节点

4. 删除

   删除链表的第$i\(1{\leq}i{\leq}n\)$个位置上的节点

   1. 先找到链表的第i-1个节点p
   2. 在找到要被删除的第i个节点s
   3. p.next=s.next; 无利用的被删除节点会被jvm自动回收

#### 循环链表

循环链表\(CirculaLr inkedList\)是另一种形式的链式存储结构。其特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。由此，从表中任一结点出发均可找到表中其他结点， 图为单链的循环链表。类似地，还可以有多重链的循环链表。

#### 双向链表

以上讨论的链式存储结构的结点中只有一个指示直接后继的指针域， 由此，从某个结点出发只能顺指针向后寻查其他结点。 若要寻查结点的直接前驱，则必须从表头指针出发。 换句话说， 在单链表中，查找直接后继结点的执行时间为O\(1\), 而查找直接前驱的执行时间为O\(n\)。 为克服 单链表这种单向性的缺点，可利用双向链表 \(Double Linked List\)。

顾名思义， 在双向链表的结点中有两个指针域，一个指向直接后继，另一个指向直接前驱。节点结构如图\(a\)所示。

和单链的循环表类似， 双向链表也可以有循环表， 如图\(c\)所示。 图\(b\)所示为只有一个表头结点的空表。

### 顺序表和链表的比较

#### 空间性能

顺序表的存储空间必须预先分配，元素个数扩充受一定限制，易造成存储空间浪费或空间溢出现象;而链表不需要为其预先分配空间，只要内存空间允许，链表中的元素个数就没有限制。

基于此，当线性表的长度变化较大，难以预估存储规模时，宜采用链表作为存储结构。当线性表的长度变化不大，易千事先确定其大小时，为了节约存储空间，宜采用顺序表作为存储结构。

#### 时间性能

* 存取元素的效率

  顺序表是由数组实现的，它是一种随机存取结构，指定任意一个位置序号i 都可以在O\(1\) 时间内直接存取该位置上的元素， 即取值操作的效率高;而链表是一种顺序存取结构，按位置访问链表中第i个元素时， 只能从表头开始依次向后遍历链表，直到找到第i个位置上的元素，时间复杂度为 O\(n\), 即取值操作的效率低。

  基于此，若线性表的主要操作是和元素位置紧密相关的这类取值操作，很少做插入或删除时， 宜采用顺序表作为存储结构。

* 插入和删除操作的效率

  对于链表，在确定插入或删除的位置后，插入或删除操作无需移动数据， 只需要修改指针， 时间复杂度为O\(1\)。而对于顺序表，进行插入或删除时，平均要移动表中近一半的结点，时间复杂度为O\(n\)。 尤其是当每个结点的信息量较大时，移动结点的时间开销就相当可观。

  基于此，对于频繁进行插入或删除操作的线性表，宜采用链表作为存储结构。

### 栈和队列

栈和队列是两种重要的线性结构。从数据结构角度看， 栈和队列也是线性表， 其特殊性在于栈和队列的基本操作是线性表操作的子集， 它们是操作受限的线性表， 因此， 可称为限定性的数据结构。但从数据类型角度看，它们是和线性表不相同的两类重要的抽象数据类型。

#### 栈

栈 \(stack\) 是限定仅在表尾进行插入或删除操作的线性表。 因此， 对栈来说， 表尾端有其特殊含义， 称为栈顶 \(top\), 相应地， 表头端称为栈底 \(bottom\)。 不含元素的空表称为空栈。

假设栈$S=\(a\_1,a\_2,...,a\_n\)$，则称$a\_1$为栈底元素， $a\_n$为栈顶元素。 栈中元素按,, a2, ···, an 的次 序进栈， 退栈的第一个元素应为栈顶元素。 换句话说 ， 栈的修改是按后进先出的原则进行的， 如 图 3.1 \(a\) 所示。 因此， 栈又称为后进先出 \(Last In First Out, LIFO\) 的线性表。

栈的主要基本操作有：

`InitStack()`：构造一个空栈。

`DestroyStack()`:栈被销毁。

`ClearStack()`:清为空栈。

`StackEmpty()`:若栈为空栈，则返回true，否则返回false。

`StackLength()`:返回栈的元素个数， 即栈的长度。

`GetTop()`:返回栈顶元素， 不修改栈顶指针。

`Push(e)`:插入元素e为新的栈顶元素。

`Pop()`:返回栈顶元素。

`StackTraverse()`:从栈底到栈顶依次对栈的每个数据元素进行访问。

#### 队列

和栈相反，队列\(queue\)是一种先进先出\(Fri st In First Out, FIFO\)的线性表。它只允许在表的一端进行插入，而在另一端删除元素。这和日常生活中的排队是一致的，最早进入队列的元素最早离开。在队列中，允许插入的一端称为队尾\(rear\), 允许删除的一端则称为队头\(front\)。假设队列为$q=\(a_1,a\_2...,a\_n\)$, 那么$a\_1$就是队头元素，$a\_n$则是队尾元素。队列中的元素是按照$a\_1,a\_2...,a\_n$的顺 序进入的，退出队列也只能按照这个次序依次退出。也就是说，只有在$a\_1,a\_2...,a_{n-1}$都离开队列之后，$a\_n$才能退出队列。

队列的基本操作有：

`InitQueue()`:构造一个空队列。

`DestroyQueue()`:队列被销毁， 不再存在。

`ClearQueue()`:清为空队列。

`QueueEmpty()`:若为空队列，则返回true, 否则返回false。

`QueueLength()`:返回元素的个数，即队列的长度。

`GetHead()`:返回队头元素。

`EnQueue(e)`:插入元素e为新的队尾元素。

`DeQueue()`:删除队头元素，并返回其值。

`QueueTraverse()`:从队头到队尾，依次对Q的每个数据元素访问。

## 广义表

广义表\(Generalized list\)是线性表的推广。对于线性表而言，元素都是基本的单元素，它可以是一个数或一个结构。若放松对表元素的这种限制，容许它们具有其自身结构，这样就产生了广义表的概念。广义表中元素不仅可以是单元素也可以是另一个广义表。

其中tag是标志域：0表示节点是单元素，1表示节点是广义表。子表指针域Sublist与单元素数据域Data复用，即共用存储空间。Next指向后继节点。

广义表的例子：

`A=()`:A是一个空表，其长度为0.

`B=(e)`:B只有一个原子e，其长度为1.

`C=(a,(b,c,d))`:C的长度为2，两个元素分别为原子a和子表\(b,c,d\).

`D=(A,B,C)`:D的长度为3，3个元素都是广义表。

广义表的重要实现：

`GetHead()`：取出的表头为非空广义表的第一个元素。如GetHead\(B\)=e, GetHead\(D\)=A

`GetTail()`：取出的表尾为除去表头之外，由其余元素构成的表。即表尾一定是一个广义表。如GetTail\(B\)=\(\), GetTail\(D\)=\(B,C\)

## 多重链表

多重链表：链表中的节点可能同时隶属于多个链

* 多重链表中结点的指针域会有多个，如前面例子包含了Next和 SubList两个指针域； 
* 但包含两个指针域的链表并不一定是多重链表，比如双向链表就不是多重链表。 
* 多重链表有广泛的用途： 基本上如树、图这样相对复杂的数据结构都可以采用多重链表方式实现存储。

举例使用多重链表实现矩阵。如果使用二维数组实现矩阵会存在两个缺陷：一是需要事先确定好数组的大小，二是对于稀疏矩阵来说，将造成大量的存储空间浪费。

解决：使用典型的多重链表---十字链表来存储稀疏矩阵。其中主要解决了两个问题：一是每个坐标数据如何存储，二是多个坐标数据之间的关系如何表达。

* 只存储矩阵非0元素项。每个节点的数据域包括：行坐标Row、列坐标Col、数值Value
* 每个节点通过两个指针域，把同行、同列串起来；
  * 行指针（或称为向右指针）Right
  * 列指针（或称为向下指针）Down

上图为矩阵A的多重链表存储概略图。首先最左上角声明了矩阵的大小，是4行5列且非0的数据有7个，是整个矩阵的入口。

## 串

串是一种特殊的 线性表， 其特殊性体现在数据元素是一个字符， 也就是说， 串是一种内容受限的线性表。串\(string\)\(或字符串\)是由零个或多个字符组成的有限序列，一般记为$s=\(a\_1,a\_2...a\_n\) \(n{\geq}0\)$。

串的逻辑结构和线性表极为相似，区别仅在于串的数据对象约束为字符集。然而，串的基本操作和线性表有很大差别。在线性表的基本操作中，大多以“单个元素”作为操作对象。例如，在线性表中查找某个元素，求取某个元素，在某个位置上插入一个元素或删除一个元素等;而在串的基本操作中，通常以 “串的整体” 作为操作对象，例如，在串中查找某个子串，求取一个子串，在串的某个位置上插入一个子串，以及删除一个子串等。

与线性表类似， 串也有两种基本存储结构:顺序存储和链式存储。但考虑到存储效率和算法的方便性， 串多采用顺序存储结构。

### 串的顺序存储

类似于线性表的顺序存储结构， 用一组地址连续的存储单元存储串值的字符序列。 按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区（也可以动态的分配和释放字符串数组空间）。

### 串的链式存储

顺序串的插入和删除操作不方便，需要移动大量的字符。 因此，可采用单链表方式存储串。 由于串结构的特殊性，结构中的每个数据元素是一个字符，则在用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。

图a为节点大小为4（即每个节点存放4个字符）的链表。图b所示为节点大小为1的链表。当结点大小大于1时，由于串长不一定是结点大小的整倍数，则链表中的最后一个结点不一定全被串值占满，此时通常补上"\#"或其他的非串值字符\( 通常"\#"不属于串的字符集，是一个特殊的符号\)。

### 串的模式匹配算法

#### BF算法

#### KMP算法

## 数组

数组是由类型相同的数据元素构成的有序集合，每个元素称为数组元素，每个元素受$n\(n{\geq}1\)$个线性关系的约束，每个元素在n个线性关系中的序号$i\_1,i\_2...i\_n$称为该元素的下标，可以通过下标访问该数据元素。因为数组中每个元素处于 $n\(n{\geq}1\)$个关系中，故称该数组为n维数组 。数组可以看成是线性表的推广，其特点是结构中的元素本身可以是具有某种结构的数据， 但属于同一数据类型。

